/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SimpleTasksBlocksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  categories: [],
  confirmTaskDeletion: false,
  dateFormat: "Automatic"
};
var VIEW_TYPE_TASKS = "simple-tasks-blocks-view";
var COLORS = {
  "Default": "",
  "Red": "rgba(233, 30, 99, 0.1)",
  "Green": "rgba(76, 175, 80, 0.1)",
  "Blue": "rgba(33, 150, 243, 0.1)",
  "Yellow": "rgba(255, 235, 59, 0.1)",
  "Purple": "rgba(156, 39, 176, 0.1)",
  "Grey": "rgba(158, 158, 158, 0.1)"
};
var SimpleTasksBlocksPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_TASKS,
      (leaf) => new TasksView(leaf, this)
    );
    this.addRibbonIcon("list-checks", "Simple tasks blocks", () => {
      void this.activateView();
    });
    this.addCommand({
      id: "create-new-task-category",
      name: "Create new task category",
      callback: () => {
        new AddCategoryModal(this.app, (name, firstTask, date) => {
          void this.addCategory(name, firstTask, date);
        }).open();
      }
    });
    this.addSettingTab(new SimpleTasksBlocksSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.refreshViews();
  }
  // On ne stocke rien, on boucle sur toutes les instances ouvertes
  refreshViews() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_TASKS).forEach((leaf) => {
      if (leaf.view instanceof TasksView) {
        leaf.view.refresh();
      }
    });
  }
  async addCategory(name, firstTaskText, dueDate) {
    const newCategory = {
      id: Date.now().toString(),
      name,
      tasks: [],
      isCollapsed: false,
      color: ""
    };
    if (firstTaskText) {
      newCategory.tasks.push({
        id: Date.now().toString() + "-task",
        text: firstTaskText,
        completed: false,
        dueDate
      });
    }
    this.settings.categories.push(newCategory);
    await this.saveSettings();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TASKS);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_TASKS, active: true });
    }
    workspace.revealLeaf(leaf);
  }
};
var SimpleTasksBlocksSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Settings for simple tasks blocks").setHeading();
    new import_obsidian.Setting(containerEl).setName("Confirm task deletion").setDesc("Ask for confirmation before deleting a task.").addToggle((toggle) => toggle.setValue(this.plugin.settings.confirmTaskDeletion).onChange(async (value) => {
      this.plugin.settings.confirmTaskDeletion = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc("Choose how dates are displayed.").addDropdown((dropdown) => dropdown.addOption("Automatic", "Automatique (selon la langue de Obsidian)").addOption("YYYY-MM-DD", "Ann\xE9e-Mois-Jour (ex: 2026-01-02)").addOption("DD-MM-YYYY", "Jour-Mois-Ann\xE9e (ex: 02-01-2026)").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
  }
};
var TasksView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.draggedCategoryIndex = null;
    this.icon = "list-checks";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TASKS;
  }
  getDisplayText() {
    return "Simple tasks blocks";
  }
  onOpen() {
    this.refresh();
    return Promise.resolve();
  }
  async onClose() {
  }
  refresh() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("stb-container");
    const header = container.createEl("div", { cls: "stb-header" });
    const grid = header.createEl("div", { cls: "stb-header-grid" });
    const leftPart = grid.createEl("div", { cls: "stb-header-part-left" });
    const centerPart = grid.createEl("div", { cls: "stb-header-part-center" });
    const addCategoryBtn = centerPart.createEl("button", { text: "+ category", cls: "mod-cta" });
    addCategoryBtn.addEventListener("click", () => {
      new AddCategoryModal(this.app, (name, firstTask, date) => {
        void this.plugin.addCategory(name, firstTask, date);
      }).open();
    });
    const rightPart = grid.createEl("div", { cls: "stb-header-part-right" });
    const toggleAllBtn = rightPart.createEl("div", { cls: "stb-header-icon clickable-icon" });
    (0, import_obsidian.setIcon)(toggleAllBtn, "chevrons-up-down");
    toggleAllBtn.setAttribute("aria-label", "Toggle collapse/expand for all categories");
    toggleAllBtn.addEventListener("click", () => {
      void this.toggleAllCategories();
    });
    const cleanBtn = rightPart.createEl("div", { cls: "stb-header-icon clickable-icon" });
    (0, import_obsidian.setIcon)(cleanBtn, "eraser");
    cleanBtn.setAttribute("aria-label", "Clean completed tasks");
    cleanBtn.addEventListener("click", () => {
      new ConfirmModal(this.app, "Delete ALL completed tasks from ALL categories?", () => {
        void this.cleanCompletedTasks();
      }).open();
    });
    const categoriesContainer = container.createEl("div", { cls: "stb-categories-list" });
    this.plugin.settings.categories.forEach((category, index) => {
      this.renderCategory(categoriesContainer, category, index);
    });
  }
  renderCategory(container, category, index) {
    const catBlock = container.createEl("div", { cls: "stb-category-block" });
    if (category.color) {
      catBlock.setCssProps({ "background-color": category.color });
    }
    catBlock.setAttribute("draggable", "true");
    catBlock.addEventListener("dragstart", (e) => {
      var _a;
      this.draggedCategoryIndex = index;
      catBlock.addClass("stb-dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", index.toString());
      if (e.dataTransfer)
        e.dataTransfer.effectAllowed = "move";
    });
    catBlock.addEventListener("dragend", () => {
      catBlock.removeClass("stb-dragging");
      this.draggedCategoryIndex = null;
      const allBlocks = container.querySelectorAll(".stb-category-block");
      allBlocks.forEach((b) => b.removeClass("stb-drag-over"));
    });
    catBlock.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (this.draggedCategoryIndex === null || this.draggedCategoryIndex === index)
        return;
      catBlock.addClass("stb-drag-over");
    });
    catBlock.addEventListener("dragleave", () => {
      catBlock.removeClass("stb-drag-over");
    });
    catBlock.addEventListener("drop", async (e) => {
      e.preventDefault();
      catBlock.removeClass("stb-drag-over");
      if (this.draggedCategoryIndex !== null && this.draggedCategoryIndex !== index) {
        await this.reorderCategories(this.draggedCategoryIndex, index);
      }
    });
    catBlock.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const menu = new import_obsidian.Menu();
      menu.addItem((item) => {
        item.setTitle("Change color").setIcon("palette");
      });
      menu.addSeparator();
      Object.keys(COLORS).forEach((colorName) => {
        menu.addItem((item) => {
          item.setTitle(colorName).setChecked(category.color === COLORS[colorName]).onClick(() => {
            category.color = COLORS[colorName];
            void this.plugin.saveSettings();
          });
        });
      });
      menu.showAtPosition({ x: event.clientX, y: event.clientY });
    });
    const catHeader = catBlock.createEl("div", { cls: "stb-category-header" });
    const dragHandle = catHeader.createEl("div", { cls: "stb-drag-handle clickable-icon" });
    (0, import_obsidian.setIcon)(dragHandle, "grip-vertical");
    const chevron = catHeader.createEl("div", { cls: "stb-cat-chevron clickable-icon" });
    (0, import_obsidian.setIcon)(chevron, category.isCollapsed ? "chevron-right" : "chevron-down");
    chevron.addEventListener("click", (e) => {
      e.stopPropagation();
      category.isCollapsed = !category.isCollapsed;
      void this.plugin.saveSettings();
    });
    const title = catHeader.createEl("h3", { text: category.name });
    title.addEventListener("click", (e) => {
      e.stopPropagation();
      this.makeEditable(title, async (newText) => {
        if (newText && newText !== category.name) {
          category.name = newText;
          await this.plugin.saveSettings();
        }
      });
    });
    const sortBtn = catHeader.createEl("div", { cls: "stb-cat-sort-btn clickable-icon" });
    (0, import_obsidian.setIcon)(sortBtn, "arrow-up-down");
    sortBtn.setAttribute("aria-label", "Sort tasks by date");
    sortBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      void this.sortCategoryTasks(category.id);
    });
    const addTaskHeaderBtn = catHeader.createEl("div", { cls: "stb-cat-add-btn clickable-icon" });
    (0, import_obsidian.setIcon)(addTaskHeaderBtn, "plus");
    addTaskHeaderBtn.setAttribute("aria-label", "Add task");
    catHeader.createEl("div", { cls: "stb-spacer" });
    const deleteCatBtn = catHeader.createEl("div", { cls: "stb-delete-cat-btn clickable-icon" });
    (0, import_obsidian.setIcon)(deleteCatBtn, "trash");
    deleteCatBtn.setAttribute("aria-label", "Delete category");
    deleteCatBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      new ConfirmModal(this.app, `Are you sure you want to delete category "${category.name}"?`, () => {
        void this.deleteCategory(category.id);
      }).open();
    });
    if (!category.isCollapsed) {
      const tasksList = catBlock.createEl("div", { cls: "stb-tasks-list" });
      category.tasks.forEach((task) => {
        this.renderTask(tasksList, category, task);
      });
      const inlineContainer = catBlock.createEl("div", { cls: "stb-add-task-inline" });
      inlineContainer.hide();
      const showInput = () => {
        inlineContainer.show();
        inlineContainer.empty();
        const wrapper = inlineContainer.createEl("div", { cls: "stb-inline-input-wrapper" });
        const input = wrapper.createEl("input", { type: "text", placeholder: "New task..." });
        input.focus();
        const dateBtn = wrapper.createEl("div", { cls: "stb-inline-date-btn clickable-icon" });
        (0, import_obsidian.setIcon)(dateBtn, "calendar");
        const dateInput = wrapper.createEl("input", { type: "date", cls: "stb-hidden-date-input" });
        dateInput.hide();
        dateBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if ("showPicker" in HTMLInputElement.prototype) {
            try {
              dateInput.showPicker();
            } catch (error) {
              if (dateInput.style.display === "none") {
                dateInput.show();
                dateInput.focus();
              } else {
                dateInput.hide();
              }
            }
          } else {
            if (dateInput.style.display === "none") {
              dateInput.show();
              dateInput.focus();
            } else {
              dateInput.hide();
            }
          }
        });
        dateInput.addEventListener("change", () => {
          if (dateInput.value) {
            dateBtn.addClass("has-date");
            dateBtn.setAttribute("title", dateInput.value);
          } else {
            dateBtn.removeClass("has-date");
            dateBtn.removeAttribute("title");
          }
        });
        const submit = async () => {
          const text = input.value.trim();
          if (text) {
            await this.addTask(category.id, text, dateInput.value || void 0);
          }
          inlineContainer.empty();
          inlineContainer.hide();
        };
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter")
            void submit();
          if (e.key === "Escape") {
            inlineContainer.empty();
            inlineContainer.hide();
          }
        });
        input.addEventListener("blur", (e) => {
          if (e.relatedTarget === dateInput || e.relatedTarget === dateBtn || wrapper.contains(e.relatedTarget)) {
            return;
          }
        });
      };
      addTaskHeaderBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        showInput();
      });
    }
  }
  formatDate(dateStr) {
    if (!dateStr)
      return "";
    const format = this.plugin.settings.dateFormat;
    let useFr = false;
    if (format === "Automatic") {
      const locale = import_obsidian.moment.locale();
      if (locale.startsWith("fr"))
        useFr = true;
    } else if (format === "DD-MM-YYYY") {
      useFr = true;
    }
    if (useFr) {
      const [y, m, d] = dateStr.split("-");
      return `${d}-${m}-${y}`;
    }
    return dateStr;
  }
  renderTask(container, category, task) {
    const taskRow = container.createEl("div", { cls: "stb-task-row" });
    const checkbox = taskRow.createEl("input", { type: "checkbox" });
    checkbox.checked = task.completed;
    checkbox.addEventListener("change", () => {
      void this.toggleTask(category.id, task.id, checkbox.checked);
    });
    const taskText = taskRow.createEl("span", { cls: "stb-task-text", text: task.text });
    if (task.completed)
      taskText.addClass("is-completed");
    taskText.addEventListener("click", (e) => {
      e.stopPropagation();
      this.makeEditable(taskText, async (newText) => {
        if (newText && newText !== task.text) {
          task.text = newText;
          await this.plugin.saveSettings();
        }
      });
    });
    const rightActions = taskRow.createEl("div", { cls: "stb-task-right-actions" });
    if (task.dueDate) {
      const formattedDate = this.formatDate(task.dueDate);
      const dateBadge = rightActions.createEl("span", { cls: "stb-date-badge", text: formattedDate });
      const todayStr = new Date().toISOString().split("T")[0];
      if (task.dueDate < todayStr) {
        dateBadge.addClass("is-overdue");
      } else if (task.dueDate === todayStr) {
        dateBadge.addClass("is-today");
      }
    }
    const dateEditBtn = rightActions.createEl("div", { cls: "stb-task-date-btn clickable-icon" });
    (0, import_obsidian.setIcon)(dateEditBtn, "calendar");
    const dateEditInput = rightActions.createEl("input", { type: "date", cls: "stb-hidden-date-input" });
    dateEditInput.hide();
    if (task.dueDate)
      dateEditInput.value = task.dueDate;
    dateEditBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if ("showPicker" in HTMLInputElement.prototype) {
        try {
          dateEditInput.showPicker();
        } catch (e2) {
          dateEditInput.show();
          dateEditInput.focus();
        }
      } else {
        dateEditInput.show();
        dateEditInput.focus();
      }
    });
    dateEditInput.addEventListener("change", () => {
      if (dateEditInput.value !== task.dueDate) {
        task.dueDate = dateEditInput.value;
        void this.plugin.saveSettings();
      }
      dateEditInput.hide();
    });
    dateEditInput.addEventListener("blur", () => {
      setTimeout(() => {
        dateEditInput.hide();
      }, 200);
    });
    const scratchpadBtn = rightActions.createEl("div", { cls: "stb-scratchpad-btn clickable-icon" });
    (0, import_obsidian.setIcon)(scratchpadBtn, "sticky-note");
    if (task.scratchpad)
      scratchpadBtn.addClass("has-content");
    scratchpadBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      new ScratchpadModal(this.app, task.scratchpad || "", (newText) => {
        if (newText !== task.scratchpad) {
          task.scratchpad = newText;
          void this.plugin.saveSettings();
        }
      }).open();
    });
    const deleteBtn = rightActions.createEl("div", { cls: "stb-delete-task-btn clickable-icon" });
    (0, import_obsidian.setIcon)(deleteBtn, "x");
    deleteBtn.addEventListener("click", () => {
      if (this.plugin.settings.confirmTaskDeletion) {
        new ConfirmModal(this.app, `Delete task "${task.text}"?`, () => {
          void this.deleteTask(category.id, task.id);
        }).open();
      } else {
        void this.deleteTask(category.id, task.id);
      }
    });
  }
  // Helper for Inline Editing
  makeEditable(element, onSave) {
    const currentText = element.innerText;
    const input = element.createEl("input", { type: "text", value: currentText, cls: "stb-inline-input" });
    element.empty();
    element.appendChild(input);
    input.focus();
    input.addEventListener("click", (e) => e.stopPropagation());
    const save = async () => {
      const newText = input.value.trim();
      if (!newText) {
        element.empty();
        element.innerText = currentText;
        return;
      }
      await onSave(newText);
    };
    const cancel = () => {
      this.refresh();
    };
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        void save();
      }
      if (e.key === "Escape") {
        cancel();
      }
    });
    input.addEventListener("blur", () => {
      void save();
    });
  }
  async sortCategoryTasks(categoryId) {
    const category = this.plugin.settings.categories.find((c) => c.id === categoryId);
    if (!category)
      return;
    const currentOrder = category.lastSortOrder || "desc";
    const newOrder = currentOrder === "asc" ? "desc" : "asc";
    const todayStr = new Date().toISOString().split("T")[0];
    category.tasks.sort((a, b) => {
      const dateA = a.dueDate || todayStr;
      const dateB = b.dueDate || todayStr;
      if (dateA === dateB)
        return 0;
      if (newOrder === "asc") {
        return dateA < dateB ? -1 : 1;
      } else {
        return dateA > dateB ? -1 : 1;
      }
    });
    category.lastSortOrder = newOrder;
    await this.plugin.saveSettings();
    new import_obsidian.Notice(`Sorted tasks ${newOrder === "asc" ? "ascending" : "descending"}`);
  }
  async reorderCategories(fromIndex, toIndex) {
    const categories = this.plugin.settings.categories;
    const [moved] = categories.splice(fromIndex, 1);
    categories.splice(toIndex, 0, moved);
    await this.plugin.saveSettings();
  }
  async addCategory(name, firstTaskText) {
    await this.plugin.addCategory(name, firstTaskText);
  }
  async deleteCategory(id) {
    this.plugin.settings.categories = this.plugin.settings.categories.filter((c) => c.id !== id);
    await this.plugin.saveSettings();
  }
  async addTask(categoryId, text, dueDate) {
    const category = this.plugin.settings.categories.find((c) => c.id === categoryId);
    if (category) {
      category.tasks.push({
        id: Date.now().toString(),
        text,
        completed: false,
        dueDate
      });
      await this.plugin.saveSettings();
    }
  }
  async toggleTask(categoryId, taskId, completed) {
    const category = this.plugin.settings.categories.find((c) => c.id === categoryId);
    if (category) {
      const task = category.tasks.find((t) => t.id === taskId);
      if (task) {
        task.completed = completed;
        await this.plugin.saveSettings();
      }
    }
  }
  async deleteTask(categoryId, taskId) {
    const category = this.plugin.settings.categories.find((c) => c.id === categoryId);
    if (category) {
      category.tasks = category.tasks.filter((t) => t.id !== taskId);
      await this.plugin.saveSettings();
    }
  }
  async toggleAllCategories() {
    const anyOpen = this.plugin.settings.categories.some((c) => !c.isCollapsed);
    this.plugin.settings.categories.forEach((c) => {
      c.isCollapsed = anyOpen;
    });
    await this.plugin.saveSettings();
  }
  async cleanCompletedTasks() {
    this.plugin.settings.categories.forEach((c) => {
      c.tasks = c.tasks.filter((t) => !t.completed);
    });
    await this.plugin.saveSettings();
  }
};
var AddCategoryModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Add new category" });
    const nameDiv = contentEl.createDiv({ cls: "stb-modal-field" });
    nameDiv.createEl("label", { text: "Category name" });
    const nameInput = nameDiv.createEl("input", { type: "text" });
    const taskDiv = contentEl.createDiv({ cls: "stb-modal-field" });
    taskDiv.createEl("label", { text: "First task name" });
    const taskInput = taskDiv.createEl("input", { type: "text" });
    const dateDiv = contentEl.createDiv({ cls: "stb-modal-field" });
    dateDiv.createEl("label", { text: "Due date (optional)" });
    const dateInput = dateDiv.createEl("input", { type: "date" });
    const buttonDiv = contentEl.createDiv({ cls: "stb-modal-actions" });
    const submitBtn = buttonDiv.createEl("button", { text: "Create", cls: "mod-cta" });
    submitBtn.addEventListener("click", () => {
      const name = nameInput.value.trim();
      const task = taskInput.value.trim();
      const date = dateInput.value;
      if (!name || !task) {
        new import_obsidian.Notice("Both fields are required.");
        return;
      }
      this.onSubmit(name, task, date || void 0);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ScratchpadModal = class extends import_obsidian.Modal {
  constructor(app, initialText, onSave) {
    super(app);
    this.initialText = initialText;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("stb-scratchpad-modal");
    contentEl.createEl("h3", { text: "Task scratchpad" });
    const textarea = contentEl.createEl("textarea", {
      cls: "stb-scratchpad-textarea",
      text: this.initialText
    });
    textarea.placeholder = "Write your notes here...";
    textarea.focus();
    textarea.setSelectionRange(this.initialText.length, this.initialText.length);
    const buttonDiv = contentEl.createDiv({ cls: "stb-modal-actions" });
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    saveBtn.addEventListener("click", () => {
      this.onSave(textarea.value);
      this.close();
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: this.message });
    const buttonDiv = contentEl.createDiv({ cls: "stb-modal-actions" });
    const confirmBtn = buttonDiv.createEl("button", { text: "Confirm", cls: "mod-warning" });
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    confirmBtn.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
